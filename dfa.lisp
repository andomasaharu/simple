
(let ((abcdefg nil))
  (defun make-rule (s c n) (make-instance 'FArule :state s :chr c :next-state n))
  (defclass FArule () ((state :accessor rule-state :initarg :state)
					   (chr :accessor rule-chr :initarg :chr)
					   (next-state :accessor rule-next-state :initarg :next-state)))
  (defmethod applies-top ((x FArule) state chr)
	(and (eql (rule-state x) state)
		 (eql (rule-chr x) chr)))
  (defmethod follow ((x FArule)) (rule-next-state x))
  (defmethod to_s ((x FArule)) (format nil "~A ~A ~A" (rule-state x) (rule-chr x) (rule-next-state x)))


  (defun make-rulebook (lst) (make-instance 'DFArulebook :rules lst))
  (defclass DFArulebook () ((rules :accessor rulebook-rules :initarg :rules)))
  (defmethod next-state ((x DFArulebook) state chr)
	(follow (rule-for x state chr)))
  (defmethod rule-for ((x DFArulebook) state chr)
	(find-if (lambda (x) (applies-top x state chr)) (rulebook-rules x)))


  (defun make-dfa (c a r) (make-instance 'DFA :current-state c :accept-states a :rulebook r))
  (defclass DFA () ((current-state :accessor dfa-current-state :initarg :current-state)
					(accept-states :accessor dfa-accept-states :initarg :accept-states)
					(rulebook :accessor dfa-rulebook :initarg :rulebook)))
  (defmethod acceptingp ((x DFA)) (find (dfa-current-state x) (dfa-accept-states x)))
  (defmethod read-character ((x DFA) c) (setf (slot-value x 'current-state) (next-state (dfa-rulebook x) (dfa-current-state x) c)))
  (defmethod read-string ((x DFA) s) (map 'list (lambda (c) (read-character x c)) s))


  (defun make-dfad (s a r) (make-instance 'DFAdesign :start-state s :accept-states a :rulebook r))
  (defclass DFAdesign () ((start-state :accessor dfad-start-state :initarg :start-state)
						  (accept-states :accessor dfad-accept-states :initarg :accept-states)
						  (rulebook :accessor dfad-rulebook :initarg :rulebook)))
  (defmethod to_dfa ((x DFAdesign)) (make-dfa (dfad-start-state x) (dfad-accept-states x) (dfad-rulebook x)))
  (defmethod acceptsp ((x DFAdesign) s) (let ((dfa (to_dfa x)))
										  (read-string dfa s)
										  (acceptingp dfa)))


  (let* ((rulebook (make-rulebook (list (make-rule 1 #\a 2)
									   (make-rule 1 #\b 1)
									   (make-rule 2 #\a 2)
									   (make-rule 2 #\b 3)
									   (make-rule 3 #\a 3)
									   (make-rule 3 #\b 3))))
		(inputs '((1 . #\a) (1 . #\b) (2 . #\b)))
		(dfa (make-dfa 1 '(3) rulebook))
		(dfad (make-dfad 1 '(3) rulebook))
		)
	(format t "~A~%" (acceptingp (make-dfa 1 '(1 3) rulebook)))
	(format t "~A~%" (acceptingp (make-dfa 1 '(3) rulebook)))
	(mapcar (lambda (x) (format t "~A~%" (next-state rulebook (car x) (cdr x)))) inputs)
	(format t "~A~%" (acceptingp dfa))
	(read-character dfa #\b)
	(format t "~A~%" (acceptingp dfa))
	(dotimes (i 3)
	  (read-character dfa #\a))
	(format t "~A~%" (acceptingp dfa))
	(read-character dfa #\b)
	(format t "~A~%" (acceptingp dfa))
	(read-string dfa "baaab")
	(format t "~A~%" (acceptingp dfa))
	(format t "~A~%" (acceptsp dfad "a"))
	(format t "~A~%" (acceptsp dfad "baa"))
	(format t "~A~%" (acceptsp dfad "baba"))
	)
  )
