(let ((abcdefg nil))
  (defun make-rule (s c n) (make-instance 'FArule :state s :chr c :next-state n))
  (defclass FArule () ((state :accessor rule-state :initarg :state)
					   (chr :accessor rule-chr :initarg :chr)
					   (next-state :accessor rule-next-state :initarg :next-state)))
  (defmethod applies-top ((x FArule) state chr)
	(and (eql (rule-state x) state)
		 (eql (rule-chr x) chr)))
  (defmethod follow ((x FArule)) (rule-next-state x))
  (defmethod to_s ((x FArule)) (format nil "~A ~A ~A" (rule-state x) (rule-chr x) (rule-next-state x)))


  (defun make-rulebook (lst) (make-instance 'DFArulebook :rules lst))
  (defclass DFArulebook () ((rules :accessor rulebook-rules :initarg :rules)))
  (defmethod next-state ((x DFArulebook) state chr)
	(follow (rule-for x state chr)))
  (defmethod rule-for ((x DFArulebook) state chr)
	(find-if (lambda (x) (applies-top x state chr)) (rulebook-rules x)))


  (defun make-dfa (c a r) (make-instance 'DFA :current-state c :accept-states a :rulebook r))
  (defclass DFA () ((current-state :accessor dfa-current-state :initarg :current-state)
					(accept-states :accessor dfa-accept-states :initarg :accept-states)
					(rulebook :accessor dfa-rulebook :initarg :rulebook)))
  (defmethod acceptingp ((x DFA)) (find (dfa-current-state x) (dfa-accept-states x)))
  (defmethod read-character ((x DFA) c) (setf (slot-value x 'current-state) (next-state (dfa-rulebook x) (dfa-current-state x) c)))
  (defmethod read-string ((x DFA) s) (map 'list (lambda (c) (read-character x c)) s))


  (defun make-dfad (s a r) (make-instance 'DFAdesign :start-state s :accept-states a :rulebook r))
  (defclass DFAdesign () ((start-state :accessor dfad-start-state :initarg :start-state)
						  (accept-states :accessor dfad-accept-states :initarg :accept-states)
						  (rulebook :accessor dfad-rulebook :initarg :rulebook)))
  (defmethod to_dfa ((x DFAdesign)) (make-dfa (dfad-start-state x) (dfad-accept-states x) (dfad-rulebook x)))
  (defmethod acceptsp ((x DFAdesign) s) (let ((dfa (to_dfa x)))
										  (read-string dfa s)
										  (acceptingp dfa)))


  (defun make-nfarulebook (r) (make-instance 'NFArulebook :rules r))
  (defclass NFArulebook () ((rules :accessor rulebook-rules :initarg :rules)))
  (defmethod next-states ((x NFArulebook) states chr) (reduce (lambda (acc x) (nconc x acc)) (mapcar (lambda (state) (follow-rules-for x state chr)) states) :initial-value nil))
  (defmethod follow-rules-for ((x NFArulebook) state chr) (mapcar #'follow (rules-for x state chr)))
  (defmethod rules-for ((x NFArulebook) state chr) (remove-if-not (lambda (rule) (applies-top rule state chr)) (rulebook-rules x) ))
  (defmethod follow-free-moves ((x NFArulebook) states) (let ((more-states (next-states x states nil)))
														  (if (reduce (lambda(acc x) (and (find x states) acc)) more-states :initial-value t)
															states
															(follow-free-moves x (append more-states states)))))


  (defun make-nfa (c a r) (make-instance 'NFA :current-states c :accept-states a :rulebook r))
  (defclass NFA () ((current-states :accessor nfa-current-states0 :initarg :current-states)
					(accept-states :accessor nfa-accept-states :initarg :accept-states)
					(rulebook :accessor nfa-rulebook :initarg :rulebook)))
  (defmethod acceptingp ((x NFA)) (find-if (lambda (as) (find-if (lambda (cs) (eql cs as)) (nfa-current-states x))) (nfa-accept-states x)))
  (defmethod read-character ((x NFA) c) (setf (slot-value x 'current-states) (next-states (nfa-rulebook x) (nfa-current-states x) c)))
  (defmethod read-string ((x NFA) s) (map 'list (lambda (c) (read-character x c)) s))
  ;(defmethod nfa-current-states ((x NFA)) (follow-free-moves (nfa-rulebook x) (nfa-current-states0 x)))
  (defmethod nfa-current-states ((x NFA)) (nfa-current-states0 x))


  (defun make-nfad (s a r) (make-instance 'NFAdesign :start-state s :accept-states a :rulebook r))
  (defclass NFAdesign () ((start-state :accessor nfad-start-state :initarg :start-state)
						  (accept-states :accessor nfad-accept-states :initarg :accept-states)
						  (rulebook :accessor nfad-rulebook :initarg :rulebook)))
  (defmethod acceptsp ((x NFAdesign) s) (let ((nfa (to_nfa x)))
										  (read-string nfa s)
										  (acceptingp nfa)))
  (defmethod to_nfa ((x NFAdesign)) (make-nfa (list (nfad-start-state x)) (nfad-accept-states x) (nfad-rulebook x)))


  (defun nfatest ()
	(let* ((rulebook (make-nfarulebook (list (make-rule 1 nil 2)
											 (make-rule 1 nil 4)
											 (make-rule 1 #\a 1)
											 (make-rule 1 #\b 1)
											 (make-rule 1 #\b 2)
											 (make-rule 2 #\a 3)
											 (make-rule 2 #\b 3)
											 (make-rule 3 #\a 4)
											 (make-rule 3 #\b 4))))
		   (nfa (make-nfa '(1) '(4) rulebook))
		   (nfa0 (make-nfa '(1) '(4) rulebook))
		   (nfad (make-nfad 1 '(2 4) rulebook))
		   )
	  (format t "~A~%" (next-states rulebook '(1) nil))
	  (format t "~A~%" (next-states rulebook '(1) #\b))
	  (format t "~A~%" (next-states rulebook '(1 2) #\a))
	  (format t "~A~%" (next-states rulebook '(1 3) #\b))
	  (format t "~A~%" (acceptingp (make-nfa '(1) '(4) rulebook)))
	  (format t "~A~%" (acceptingp (make-nfa '(1 2 4) '(4) rulebook)))
	  (format t "~A~%" (acceptingp nfa))
	  (read-character nfa #\b)
	  (format t "~A~%" (acceptingp nfa))
	  (read-character nfa #\a)
	  (format t "~A~%" (acceptingp nfa))
	  (read-character nfa #\b)
	  (format t "~A~%" (acceptingp nfa))
	  (format t "~A~%" (acceptingp nfa0))
	  (read-string nfa0 "bbbbb")
	  (format t "~A~%" (acceptingp nfa0))
	  (format t "~A~%" (acceptsp nfad "bab"))
	  (format t "~A~%" (acceptsp nfad "bbbbb"))
	  (format t "~A~%" (acceptsp nfad "bbabb"))
	  (format t "~A~%" (follow-free-moves rulebook '(1)))
	  (format t "~A~%" (acceptsp nfad "aa"))
	  (format t "~A~%" (acceptsp nfad "aaa"))
	  (format t "~A~%" (acceptsp nfad "aaaaa"))
	  (format t "~A~%" (acceptsp nfad "aaaaaa"))
	  ))
  (nfatest)
  (defun dfatest ()
	(let* ((rulebook (make-rulebook (list (make-rule 1 #\a 2)
										  (make-rule 1 #\b 1)
										  (make-rule 2 #\a 2)
										  (make-rule 2 #\b 3)
										  (make-rule 3 #\a 3)
										  (make-rule 3 #\b 3))))
		   (inputs '((1 . #\a) (1 . #\b) (2 . #\b)))
		   (dfa (make-dfa 1 '(3) rulebook))
		   (dfad (make-dfad 1 '(3) rulebook))
		   )
	  (format t "~A~%" (acceptingp (make-dfa 1 '(1 3) rulebook)))
	  (format t "~A~%" (acceptingp (make-dfa 1 '(3) rulebook)))
	  (mapcar (lambda (x) (format t "~A~%" (next-state rulebook (car x) (cdr x)))) inputs)
	  (format t "~A~%" (acceptingp dfa))
	  (read-character dfa #\b)
	  (format t "~A~%" (acceptingp dfa))
	  (dotimes (i 3)
		(read-character dfa #\a))
	  (format t "~A~%" (acceptingp dfa))
	  (read-character dfa #\b)
	  (format t "~A~%" (acceptingp dfa))
	  (read-string dfa "baaab")
	  (format t "~A~%" (acceptingp dfa))
	  (format t "~A~%" (acceptsp dfad "a"))
	  (format t "~A~%" (acceptsp dfad "baa"))
	  (format t "~A~%" (acceptsp dfad "baba"))
	  )
	)
  )
